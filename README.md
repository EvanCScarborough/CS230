# CS230
A portfolio artifact from my CS-230 class.

In my CS-230 class, we were given a series of projects that simulated working on software for a client called The Gaming Room. The Gaming Room wanted me to create a multi-platform web app for their game Draw It or Lose It using a server-client architecture.

In this repository is the software design template I created for The Gaming Room. I went into a lot of detail comparing and constrasting Windows, Mac, mobile, and Linux operating systems, discussing their potential uses as clients, servers, and the development tools available for them, settling on a recommendation of Linux OS for the Draw It or Lose It servers.

Having such a detailed design document is helpful when writing the softare because it provides a bird's-eye view of the project, serving as a reminder of its long-term goals and helping to inform the steps taken to reach them. It also documents any decisions made in advance of the actual development which, on a team, helps to keep everyone on the same page and ensures compatibility.

If I were to revisit this assignment, I would add information about the proposed system architecture - perhaps a flowchart or diagram that describes the transfers of information that will take place between the client, server, and database. This was not required for this particular assignment, but for a real project it would be very important information to include.

When designing software for a client, that client's needs should be the foremost consideration. In the case of this project, the client wanted an application that was highly secure. Interpreting the client's needs and implementing them into the design of the software is a matter of precise communication and alignment of priorities; by communicating clearly with a client, you come away with the best possible picture of what it is they want, which allows you to put yourself in their shoes and design software with their priorities in mind.

Designing this particular application, I found UML diagrams to be especially helpful. They clearly and concisely describe relationships between classes, and provide a helpful way to visualize and even tweak those relationships before any code is written. They are also a powerful form of documentation that can help new team members quickly grasp the class structure of a complex application.
